import { __decorate } from 'tslib';
import { Renderer2, Input, ViewChild, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import QRCode from 'qrcode';

import * as ɵngcc0 from '@angular/core';

const _c0 = ["qrcElement"];
var NgxQrcodeElementTypes;
(function (NgxQrcodeElementTypes) {
    NgxQrcodeElementTypes["URL"] = "url";
    NgxQrcodeElementTypes["IMG"] = "img";
    NgxQrcodeElementTypes["CANVAS"] = "canvas";
})(NgxQrcodeElementTypes || (NgxQrcodeElementTypes = {}));
var NgxQrcodeErrorCorrectionLevels;
(function (NgxQrcodeErrorCorrectionLevels) {
    NgxQrcodeErrorCorrectionLevels["LOW"] = "L";
    NgxQrcodeErrorCorrectionLevels["MEDIUM"] = "M";
    NgxQrcodeErrorCorrectionLevels["QUARTILE"] = "Q";
    NgxQrcodeErrorCorrectionLevels["HIGH"] = "H";
})(NgxQrcodeErrorCorrectionLevels || (NgxQrcodeErrorCorrectionLevels = {}));

const DEFAULT_VALUES = {
    elementType: NgxQrcodeElementTypes.URL,
    cssClass: 'qrcode',
    value: 'https://www.techiediaries.com',
    version: '',
    errorCorrectionLevel: NgxQrcodeErrorCorrectionLevels.MEDIUM,
    margin: 4,
    scale: 4,
    width: 10,
    colorDark: '#000',
    colorLight: '#FFF'
};

let QrcodeComponent = class QrcodeComponent {
    constructor(renderer) {
        this.renderer = renderer;
        this.elementType = DEFAULT_VALUES.elementType;
        this.cssClass = DEFAULT_VALUES.cssClass;
        this.value = DEFAULT_VALUES.value;
        this.version = DEFAULT_VALUES.version;
        this.errorCorrectionLevel = DEFAULT_VALUES.errorCorrectionLevel;
        this.margin = DEFAULT_VALUES.margin;
        this.scale = DEFAULT_VALUES.scale;
        this.width = DEFAULT_VALUES.width;
        this.colorDark = DEFAULT_VALUES.colorDark;
        this.colorLight = DEFAULT_VALUES.colorLight;
    }
    ngOnChanges() {
        this.createQRCode();
    }
    createQRCode() {
        if (!this.value) {
            return;
        }
        let element;
        switch (this.elementType) {
            case NgxQrcodeElementTypes.CANVAS:
                element = this.renderer.createElement('canvas');
                this.toCanvas(element).then(() => {
                    this.renderElement(element);
                }).catch(e => {
                    this.removeElementChildren();
                    console.error(e);
                });
                break;
            default:
                element = this.renderer.createElement('img');
                this.toDataURL().then((src) => {
                    element.setAttribute('src', src);
                    if (this.alt) {
                        element.setAttribute('alt', this.alt);
                    }
                    this.renderElement(element);
                }).catch(e => {
                    this.removeElementChildren();
                    console.error(e);
                });
        }
    }
    toDataURL() {
        return QRCode.toDataURL(this.value, {
            version: this.version,
            errorCorrectionLevel: this.errorCorrectionLevel,
            margin: this.margin,
            scale: this.scale,
            width: this.width,
            color: {
                dark: this.colorDark,
                light: this.colorLight
            }
        });
    }
    toCanvas(canvas) {
        return QRCode.toCanvas(canvas, this.value, {
            version: this.version,
            errorCorrectionLevel: this.errorCorrectionLevel,
            margin: this.margin,
            scale: this.scale,
            width: this.width,
            color: {
                dark: this.colorDark,
                light: this.colorLight
            }
        });
    }
    renderElement(element) {
        this.removeElementChildren();
        this.renderer.appendChild(this.qrcElement.nativeElement, element);
    }
    removeElementChildren() {
        for (const node of this.qrcElement.nativeElement.childNodes) {
            this.renderer.removeChild(this.qrcElement.nativeElement, node);
        }
    }
};
QrcodeComponent.ɵfac = function QrcodeComponent_Factory(t) { return new (t || QrcodeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
QrcodeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: QrcodeComponent, selectors: [["ngx-qrcode"]], viewQuery: function QrcodeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.qrcElement = _t.first);
    } }, inputs: { elementType: "elementType", cssClass: "cssClass", value: "value", version: "version", errorCorrectionLevel: "errorCorrectionLevel", margin: "margin", scale: "scale", width: "width", colorDark: "colorDark", colorLight: "colorLight", alt: "alt" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 2, consts: [["qrcElement", ""]], template: function QrcodeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", null, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClass);
    } }, encapsulation: 2, changeDetection: 0 });
QrcodeComponent.ctorParameters = () => [
    { type: Renderer2 }
];
__decorate([
    Input()
], QrcodeComponent.prototype, "elementType", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "cssClass", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "alt", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "value", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "version", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "errorCorrectionLevel", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "margin", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "scale", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "width", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "colorDark", void 0);
__decorate([
    Input()
], QrcodeComponent.prototype, "colorLight", void 0);
__decorate([
    ViewChild('qrcElement')
], QrcodeComponent.prototype, "qrcElement", void 0);

let NgxQRCodeModule = class NgxQRCodeModule {
};
NgxQRCodeModule.ɵfac = function NgxQRCodeModule_Factory(t) { return new (t || NgxQRCodeModule)(); };
NgxQRCodeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxQRCodeModule });
NgxQRCodeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(QrcodeComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-qrcode',
                template: `<div #qrcElement [class]="cssClass"></div>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }]; }, { elementType: [{
            type: Input
        }], cssClass: [{
            type: Input
        }], value: [{
            type: Input
        }], version: [{
            type: Input
        }], errorCorrectionLevel: [{
            type: Input
        }], margin: [{
            type: Input
        }], scale: [{
            type: Input
        }], width: [{
            type: Input
        }], colorDark: [{
            type: Input
        }], colorLight: [{
            type: Input
        }], alt: [{
            type: Input
        }], qrcElement: [{
            type: ViewChild,
            args: ['qrcElement']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxQRCodeModule, { declarations: [QrcodeComponent], exports: [QrcodeComponent] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxQRCodeModule, [{
        type: NgModule,
        args: [{
                declarations: [QrcodeComponent],
                exports: [QrcodeComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-qrcode
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxQRCodeModule, NgxQrcodeElementTypes, NgxQrcodeErrorCorrectionLevels, QrcodeComponent };

//# sourceMappingURL=techiediaries-ngx-qrcode.js.map